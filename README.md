# Assignment Report: Syntax, Semantics, and Memory Management

## Table of Contents
1. [Introduction](#introduction)
2. [Part 1: Analyzing Syntax and Semantics](#part-1-analyzing-syntax-and-semantics)
   - [Section 1: Syntax Errors in Python, JavaScript, and C++](#section-1-syntax-errors)
   - [Section 2: Semantic Analysis in Python, JavaScript, and C++](#section-2-semantic-analysis)
3. [Part 2: Memory Management](#part-2-memory-management)
   - [Section 3: Memory Management in Rust, Java, and C++](#section-3-memory-management)
4. [Repository Structure and Execution](#repository-structure-and-execution)
5. [Conclusion](#conclusion)

## Introduction
This report details an assignment that involved analyzing syntax and semantic differences across multiple programming languages as well as comparing memory management techniques. The assignment tasks include:

- **Part 1:** Modifying sample code to introduce syntax errors and explaining the resulting error messages for Python, JavaScript, and C++.
- **Part 2:** Developing programs in Rust, Java, and C++ that demonstrate different memory management strategies (ownership in Rust, garbage collection in Java, and manual memory management in C++).
- Utilizing a single shell script to compile and run all code, while ensuring that missing files are skipped without terminating the entire process.
- Organizing the project in a Git repository with a structured folder hierarchy.

## Part 1: Analyzing Syntax and Semantics

### Section 1: Syntax Errors
The first section involved modifying code examples to deliberately introduce syntax errors and then analyzing the error messages generated by each language's interpreter or compiler.

#### Python Example
- **Modifications:** 
  - Replaced the digit `0` with the letter `o`.
  - Removed the colon at the end of the function definition.
- **Error Messages:**
  - A missing colon produces a `SyntaxError: invalid syntax`.
  - The use of `o` instead of `0` results in a `NameError` since the variable `o` is undefined.

#### JavaScript Example
- **Modifications:** 
  - Replaced the digit `0` with the letter `o`.
  - Introduced a space in the function call (e.g., `calculate Sum` instead of `calculateSum`).
- **Error Messages:**
  - Using `o` triggers a `ReferenceError: o is not defined`.
  - The malformed function call results in a syntax or parse error, preventing the code from executing.

#### C++ Example
- **Modifications:** 
  - Replaced `0` with `o` in variable initializations and loop conditions.
  - Removed necessary semicolons (e.g., after array declarations).
- **Error Messages:**
  - The compiler raises errors such as `error: 'o' was not declared in this scope` and complains about missing semicolons.
  - These errors occur at compile time, preventing the executable from being built.

### Section 2: Semantic Analysis
This section includes sample programs in Python, JavaScript, and C++ that explore key semantic differences such as type systems, scoping rules, and closures.

#### Python: Closures and Dynamic Typing
```python
def outer():
    x = 10
    def inner():
        nonlocal x  # Allows modification of the outer variable.
        x += 1
        return x
    return inner

closure_function = outer()
print("Python closure call 1:", closure_function())  # Output: 11
print("Python closure call 2:", closure_function())  # Output: 12
```

	•	Type System: Dynamically typed.
	•	Scoping: Function-level scope with closures enabled using nonlocal.

JavaScript: Closures and Dynamic Typing


```javascript
function outer() {
    let x = 10;
    function inner() {
        x += 1;
        return x;
    }
    return inner;
}

const closureFunction = outer();
console.log("JavaScript closure call 1:", closureFunction());  // Output: 11
console.log("JavaScript closure call 2:", closureFunction());  // Output: 12

```

	•	Type System: Dynamically typed.
	•	Scoping: Lexical scoping with block-level scope using let and const.

C++: Lambda Expressions and Static Typing

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    // Lambda captures 'x' by value, but marked mutable to allow modification.
    auto inner = [x](int add) mutable -> int {
        x += add;
        return x;
    };
    cout << "C++ lambda call 1: " << inner(1) << endl;  // Output: 11
    cout << "C++ lambda call 2: " << inner(1) << endl;  // Output: 12
    return 0;
}
```

	•	Type System: Statically typed.
	•	Scoping: Block-level scoping with explicit capture lists in lambdas.

Key Semantic Differences:

	1.	Type Checking: Python and JavaScript are dynamically typed (checked at runtime), whereas C++ is statically typed (checked at compile time).
 
	2.	Scoping Rules: Python uses function-level scoping (with nonlocal for closures), JavaScript supports both function and block-level scoping, and C++ enforces block-level scoping.
 
	3.	Closure Implementation: Python and JavaScript create closures implicitly, while C++ requires an explicit capture list in lambda expressions.

Part 2: Memory Management

Section 3: Memory Management in Rust, Java, and C++

This part compares how different languages handle dynamic memory allocation and deallocation.

Rust
```rs
fn main() {
    let x = Box::new(42);  // Allocates memory on the heap.
    println!("The value of x is: {}", x);
    // Memory is automatically freed when 'x' goes out of scope.
}
```

	•	Approach: Uses ownership and borrowing, eliminating the need for a garbage collector.
	•	Error Handling: Compile-time checks prevent issues like dangling pointers and memory leaks.

Java
```java
public class MemoryDemo {
    public static void main(String[] args) {
        Integer[] numbers = new Integer[5];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = new Integer(i);
        }
        System.out.println("Numbers allocated in Java.");
        // Garbage collection handles memory deallocation automatically.
    }
}
```
	•	Approach: Uses automatic garbage collection to reclaim unused memory.
	•	Error Handling: Although memory leaks are less common, lingering references can still cause issues.

C++

```cpp
#include <iostream>
using namespace std;

int main() {
    int* numbers = new int[5];  // Manual allocation.
    for (int i = 0; i < 5; i++) {
        numbers[i] = i;
    }
    cout << "Numbers allocated in C++." << endl;
    delete[] numbers;  // Manual deallocation.
    return 0;
}
```
	•	Approach: Requires explicit allocation with new and deallocation with delete.
	•	Error Handling: The programmer is responsible for preventing memory leaks and avoiding dangling pointers.

Repository Structure and Execution

The project is organized with a clear folder hierarchy. An example directory structure is:

```bash
src/
  main.sh         # Shell script to run all code files.
  1/
    1.py
    1.cpp
    1.java
    1.rs
  2/
    2.py
    2.cpp
    2.java
    2.rs
  3/
    3.py
    3.cpp
    3.java
    3.rs
```
Shell Script: main.sh

The following script runs each file if it exists. It skips files that are missing, ensuring the script completes without terminating unexpectedly.

```bash
#!/bin/bash
echo "=========================================="
for folder in 1 2 3; do
    echo "Processing folder $folder"
    
    # Python: folder/folder.py
    if [ -f "$folder/$folder.py" ]; then
        echo "Running Python program in folder $folder..."
        python3 "$folder/$folder.py"
        echo "Python program in folder $folder finished."
    else
        echo "Python file not found in folder $folder. Skipping."
    fi

    # C++: folder/folder.cpp
    if [ -f "$folder/$folder.cpp" ]; then
        echo "Compiling C++ program in folder $folder..."
        g++ -std=c++11 "$folder/$folder.cpp" -o "$folder/${folder}_cpp_executable"
        echo "Running C++ program in folder $folder..."
        "./$folder/${folder}_cpp_executable"
        echo "C++ program in folder $folder finished."
    else
        echo "C++ file not found in folder $folder. Skipping."
    fi

    # Java: folder/folder.java
    if [ -f "$folder/$folder.java" ]; then
        echo "Compiling Java program in folder $folder..."
        javac "$folder/$folder.java" -d "$folder"
        echo "Running Java program in folder $folder..."
        java -cp "$folder" "$folder"
        echo "Java program in folder $folder finished."
    else
        echo "Java file not found in folder $folder. Skipping."
    fi

    # Rust: folder/folder.rs
    if [ -f "$folder/$folder.rs" ]; then
        echo "Compiling Rust program in folder $folder..."
        rustc "$folder/$folder.rs" -o "$folder/${folder}_rust_executable"
        echo "Running Rust program in folder $folder..."
        "./$folder/${folder}_rust_executable"
        echo "Rust program in folder $folder finished."
    else
        echo "Rust file not found in folder $folder. Skipping."
    fi

    echo "------------------------------------------"
done
echo "All available programs executed (or skipped) successfully."
```

Running the Script
	1.	Open a terminal and navigate to the src directory.
	2.	Make the script executable:

```bash
chmod +x main.sh
```


3.	Run the script:


```bash
./main.sh
```


Conclusion

This assignment highlights:

	•	Syntax and Semantic Analysis: The differences in error handling, type checking, scoping, and closure implementation in Python, JavaScript, and C++.
 
	•	Memory Management: The distinct approaches in Rust (ownership and borrowing), Java (garbage collection), and C++ (manual management).
 
	•	Project Organization: A structured repository with a unified shell script to run all code samples, ensuring that missing files do not terminate the overall execution.
